{"componentChunkName":"component---src-pages-blog-stt-a-journey-to-10-word-error-rate-mdx","path":"/blog/stt/a-journey-to-10-word-error-rate","result":{"data":{"mdx":{"id":"982811f7-0b40-5746-979b-fe555b2ea5a6","excerpt":"We believe speech interfaces will be a big part of how people interact with their devices in the future. Today we are\nexcited to announceâ€¦","body":"var _excluded = [\"components\"];\n\nvar _templateObject;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar pageQuery = graphql(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n  query($fileAbsolutePath: String) {\\n    ...SidebarPageFragment\\n  }\\n\"])));\nvar _frontmatter = {\n  \"title\": \"A Journey to <10% Word Error Rate\",\n  \"name\": \"Reuben Morais\",\n  \"picture\": \"https://secure.gravatar.com/avatar/a0806241b0bfd0b4339c8d987d98b6db?s=128&d=mm&r=g\",\n  \"date\": \"November 29, 2017\"\n};\nvar layoutProps = {\n  pageQuery: pageQuery,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We believe speech interfaces will be a big part of how people interact with their devices in the future. Today we are\\nexcited to announce the initial release of our \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/coqui-ai/STT/releases/tag/v0.1.0\"\n  }, \"open source speech recognition\\nmodel\"), \" so that anyone can develop compelling speech experiences.\"), mdx(\"p\", null, \"The Machine Learning team has been working on an open source Automatic Speech Recognition engine modeled after the Deep\\nSpeech papers (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://arxiv.org/abs/1412.5567\"\n  }, \"1\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://arxiv.org/abs/1512.02595\"\n  }, \"2\"), \") published by Baidu. One of\\nthe major goals from the beginning was to achieve a Word Error Rate in the transcriptions of under 10%. We have made\\ngreat progress: Our word error rate on LibriSpeech\\u2019s test-clean set is 6.5%, which not only achieves our initial goal,\\nbut gets us close to human level performance.\"), mdx(\"p\", null, \"This post is an overview of the team\\u2019s efforts and ends with a more detailed explanation of the final piece of the\\npuzzle: the CTC decoder.\"), mdx(\"h3\", {\n    \"id\": \"the-architecture\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-architecture\",\n    \"aria-label\": \"the architecture permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"The Architecture\"), mdx(\"p\", null, \"Coqui STT is an end-to-end trainable, character-level, deep recurrent neural network\\n(\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Recurrent_neural_network\"\n  }, \"RNN\"), \"). In less buzzwordy terms: it\\u2019s a deep neural network\\nwith recurrent layers that gets audio features as input and outputs characters directly\\u200A\\u2014\\u200Athe transcription of the\\naudio. It can be trained using supervised learning from scratch, without any external \\u201Csources of intelligence\\u201D, like a\\ngrapheme to phoneme converter or forced alignment on the input.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/static/blog-stt-a-journey-to-10-word-error-rate-architecture-1dd53cecf9b0f6023f3d4ed8eac5fa25.gif\",\n    \"alt\": \"IMAGE\"\n  })), mdx(\"p\", null, \"This animation shows how the data flows through the network. In practice, instead of processing slices of the audio\\ninput individually, we do all slices at once.\"), mdx(\"p\", null, \"The network has five layers: the input is fed into three fully connected layers, followed by a bidirectional RNN layer,\\nand finally a fully connected layer. The hidden fully connected layers use the\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Rectifier_%28neural_networks%29\"\n  }, \"ReLU\"), \" activation. The RNN layer uses LSTM cells with\\ntanh activation.\"), mdx(\"p\", null, \"The output of the network is a matrix of character probabilities over time. In other words, for each time step the\\nnetwork outputs one probability for each character in the alphabet, which represents the likelihood of that character\\ncorresponding to what\\u2019s being said in the audio at that time. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.cs.toronto.edu/~graves/icml_2006.pdf\"\n  }, \"CTC loss\\nfunction\"), \" (PDF link) considers all alignments of the audio to the\\ntranscription at the same time, allowing us to maximize the probability of the correct transcription being predicted\\nwithout worrying about alignment. Finally, we train using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://arxiv.org/abs/1412.6980\"\n  }, \"Adam optimizer\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-data\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-data\",\n    \"aria-label\": \"the data permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"The Data\"), mdx(\"p\", null, \"Supervised learning requires data, lots and lots of it. Training a model like Coqui STT requires thousands of hours of\\nlabeled audio, and obtaining and preparing this data can be as much work, if not more, as implementing the network and\\nthe training logic.\"), mdx(\"p\", null, \"We started by downloading freely available speech corpora like\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www-lium.univ-lemans.fr/en/content/ted-lium-corpus\"\n  }, \"TED-LIUM\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.openslr.org/12/\"\n  }, \"LibriSpeech\"), \", as\\nwell as acquiring paid corpora like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://catalog.ldc.upenn.edu/LDC2004S13\"\n  }, \"Fisher\"), \" and\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://catalog.ldc.upenn.edu/ldc97s62\"\n  }, \"Switchboard\"), \". We wrote importers in Python for the different data sets that\\nconvert the audio files to WAV, split the audio and cleaned up the transcription of unneeded characters like punctuation\\nand accents. Finally we stored the preprocessed data in CSV files that can be used to feed data into the network.\"), mdx(\"p\", null, \"Using existing speech corpora allowed us to quickly start working on the model. But in order to achieve excellent\\nresults, we needed a lot more data. We had to be creative. We thought that maybe this type of speech data would already\\nexist out there, sitting in people\\u2019s archives, so we reached out to public TV and radio stations, language study\\ndepartments in universities, and basically anyone who might have labeled speech data to share. Through this effort, we\\nwere able to more than double the amount of training data we had to work with, which is now enough for training a\\nhigh-quality English model.\"), mdx(\"p\", null, \"Having a high-quality voice corpus publicly available not only helps advance our own speech recognition engine. It will\\neventually allow for broad innovation because developers, startups and researchers around can train and experiment with\\ndifferent architectures and models for different languages. It could help democratize access to deep learning for those\\nwho can\\u2019t afford to pay for thousands of hours of training data (almost everyone).\"), mdx(\"p\", null, \"To build a speech corpus that\\u2019s free, open source, and big enough to create meaningful products with, we worked with\\nMozilla\\u2019s Open Innovation team and launched the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://commonvoice.mozilla.org/en\"\n  }, \"Common Voice project\"), \" to collect\\nand validate speech contributions from volunteers all over the world. Today, the team is releasing a large collection of\\nvoice data into the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://creativecommons.org/choose/zero/\"\n  }, \"public domain\"), \". Find out more about the release on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/mozilla-open-innovation/sharing-our-common-voice-mozilla-releases-second-largest-public-voice-data-set-e88f7d6b7666\"\n  }, \"the\\nOpen Innovation Medium\\nblog\"), \".\"), mdx(\"h3\", {\n    \"id\": \"the-hardware\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#the-hardware\",\n    \"aria-label\": \"the hardware permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"The Hardware\"), mdx(\"p\", null, \"Coqui STT has over 120 million parameters, and training a model this large is a very computationally expensive task: you\\nneed lots of GPUs if you don\\u2019t want to wait forever for results. We looked into training on the cloud, but it doesn\\u2019t\\nwork financially: dedicated hardware pays for itself quite quickly if you do a lot of training. The cloud is a good way\\nto do fast hyperparameter explorations though, so keep that in mind.\"), mdx(\"p\", null, \"We started with a single machine running four Titan X Pascal GPUs, and then bought another two servers with 8 Titan XPs\\neach. We run the two 8 GPU machines as a cluster, and the older 4 GPU machine is left independent to run smaller\\nexperiments and test code changes that require more compute power than our development machines have. This setup is\\nfairly efficient, and for our larger training runs we can go from zero to a good model in about a week.\"), mdx(\"p\", null, \"Setting up distributed training with TensorFlow was an arduous process. Although it has the most mature distributed\\ntraining tools of the available deep learning frameworks, getting things to actually work without bugs and to take full\\nadvantage of the extra compute power is tricky. Our current setup works thanks to the incredible efforts of my colleague\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tilmankamp\"\n  }, \"Tilman Kamp\"), \", who endured long battles with TensorFlow,\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://slurm.schedmd.com/\"\n  }, \"Slurm\"), \", and even the Linux kernel until we had everything working.\"), mdx(\"h3\", {\n    \"id\": \"putting-it-all-together\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#putting-it-all-together\",\n    \"aria-label\": \"putting it all together permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"Putting it All Together\"), mdx(\"p\", null, \"At this point, we have two papers to guide us, a model implemented based on those papers, the resulting data, and the\\nhardware required for the training process. It turns out that replicating the results of a paper isn\\u2019t that\\nstraightforward. The vast majority of papers don\\u2019t specify all the hyperparameters they use, if they specify any at all.\\nThis means you have to spend a whole lot of time and energy doing hyperparameter searches to find a good set of values.\\nOur initial tests with values chosen through a mix of randomness and intuition weren\\u2019t even close to the ones reported\\nby the paper, probably due to small differences in the architecture\\u200A\\u2014\\u200Afor one, we used LSTM (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Long_short-term_memory\"\n  }, \"Long short-term\\nmemory\"), \") cells instead of GRU (gated recurrent unit) cells. We\\nspent a lot of time doing a binary search on dropout ratios, we reduced the learning rate, changed the way the weights\\nwere initialized, and experimented with the size of the hidden layers as well. All of those changes got us pretty close\\nto our desired target of <10% Word Error Rate, but not there.\"), mdx(\"p\", null, \"One piece missing from our code was an important optimization: integrating our language model into the decoder. The CTC\\n(Connectionist Temporal Classification) decoder works by taking the probability matrix that is output by the model and\\nwalking over it looking for the most likely text sequence according to the probability matrix. If at time step 0 the\\nletter \\u201CC\\u201D is the most likely, and at time step 1 the letter \\u201CA\\u201D is the most likely, and at time step 2 the letter \\u201CT\\u201D\\nis the most likely, then the transcription given by the simplest possible decoder will be \\u201CCAT\\u201D. This strategy is called\\ngreedy decoding.\"), mdx(\"div\", {\n    align: \"center\"\n  }, mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"500px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"57.599999999999994%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVQoz2VSPa8BURC93m5EZKOjpRChkvADxH+gIERCJyQK29hCdDQ+KoVoSYhEQuIniEJoRINOfDQ0Nr7fO8+8tzbvTTGZO3POnLlzL0skEj6fTxTF4/H4fD6v1yv85z+73+8o3W43xOPxOJVKAcZarRbV4Il2Op0mk8lgMECp0Wj0er3VaoX84/GAr9VqOp3OZDKNRiMWCATK5TIQOMzn83q9brfb2a9pNBp4vV7v9/uLxWIkEuF5nkpms5lNp9N0Ou10OtFPzYF9vIz4akMvl8vl9XoZjYqxd7tdpVLhOA4EAnEvIz7/Mq1Wi3w2mwVFlmVGm6A7bzYbo9FIykoLtdFEWBjpMVom9C+XC4JoNEqaAMXjcUmSwuGwxWJBkm4bi8WI+b1t9WPAZzIZEvF4PDhiKPh8Pk9JzLVer5XNv5XhIY7NEa7b7dKzwZdKJavV6na7HQ4HgQn/Q6ZOi8XCYDC02+1gMIhXgSzlk8kkltRsNgVBOBwOihj785NCodBsNgMnl8t1Oh3MgvUUCgVw0Mtms+HbKOA3mUSGw2G1WkVwPp+XyyWC/X6/3W4J0+/30ZTyEP8CwP6ncwMl13MAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"IMAGE\",\n    \"title\": \"IMAGE\",\n    \"src\": \"/static/951c29bfac70e155e5037020410b8cfe/c6e3d/blog-stt-a-journey-to-10-word-error-rate-cat.png\",\n    \"srcSet\": [\"/static/951c29bfac70e155e5037020410b8cfe/43fa5/blog-stt-a-journey-to-10-word-error-rate-cat.png 250w\", \"/static/951c29bfac70e155e5037020410b8cfe/c6e3d/blog-stt-a-journey-to-10-word-error-rate-cat.png 500w\"],\n    \"sizes\": \"(max-width: 500px) 100vw, 500px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \"))), mdx(\"p\", null, \"This is a pretty good way of decoding the probabilities output by the model into a sequence of characters, but it has\\none major flaw: it only takes into account the output of the network, which means it only takes into account the\\ninformation from audio. When the same audio has two equally likely transcriptions (think \\u201Cnew\\u201D vs \\u201Cknew\\u201D, \\u201Cpause\\u201D vs\\n\\u201Cpaws\\u201D), the model can only guess at which one is correct. This is far from optimal: if the first four words in a\\nsentence are \\u201Cthe cat has tiny\\u201D, we can be pretty sure that the fifth word will be \\u201Cpaws\\u201D rather than \\u201Cpause\\u201D. Answering\\nthose types of questions is the job of a language model, and if we could integrate a language model into the decoding\\nphase of our model, we could get way better results.\"), mdx(\"p\", null, \"When we first tried to tackle this issue, we ran into a couple of blockers in TensorFlow: first, it doesn\\u2019t expose its\\nbeam scoring functionality in the Python API (probably for performance reasons); and second, the log probabilities\\noutput by the CTC loss function were (are?) \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tensorflow/tensorflow/issues/6034\"\n  }, \"invalid\"), \".\"), mdx(\"p\", null, \"We decided to work around the problem by building something like a spell checker instead: go through the transcription\\nand see if there are any small modifications we can make that increase the likelihood of that transcription being valid\\nEnglish, according to the language model. This did a pretty good job of correcting small spelling mistakes in the\\noutput, but as we got closer and closer to our target error rate, we realized that it wasn\\u2019t going to be enough. We\\u2019d\\nhave to bite the bullet and write some C++.\"), mdx(\"h3\", {\n    \"id\": \"beam-scoring-with-a-language-model\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#beam-scoring-with-a-language-model\",\n    \"aria-label\": \"beam scoring with a language model permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"Beam Scoring with a Language Model\"), mdx(\"p\", null, \"Integrating the language model into the decoder involves querying the language model every time we evaluate an addition\\nto the transcription. Going back to the previous example, when looking into whether we want to choose \\u201Cpaws\\u201D or \\u201Cpause\\u201D\\nfor the next word after \\u201Cthe cat has tiny\\u201D, we query the language model and use that score as a weight to sort the\\ncandidate transcriptions. Now we get to use information not just from audio but also from our language model to decide\\nwhich transcription is more likely. The algorithm is described in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://arxiv.org/abs/1408.2873\"\n  }, \"this paper\"), \" by\\nHannun et. al.\"), mdx(\"p\", null, \"Luckily, TensorFlow does have an extension point on its CTC beam search decoder that allows the user to supply their own\\nbeam scorer. This means all you have to do is write the beam scorer that queries the language model and plug that in.\\nFor our case, we wanted that functionality to be exposed to our Python code, so we also exposed it as a custom\\nTensorFlow operation that can be loaded using\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.tensorflow.org/api_docs/python/tf/load_op_library\"\n  }, \"tf.load_op_library\"), \".\"), mdx(\"p\", null, \"Getting all of this to work with our setup required quite a bit of effort, from fighting with the Bazel build system for\\nhours, to making sure all the code was able to handle Unicode input in a consistent way, and debugging the beam scorer\\nitself. The system requires quite a few pieces to work together:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The language model itself (we use \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://kheafield.com/code/kenlm/\"\n  }, \"KenLM\"), \" for building and querying). A\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Trie\"\n  }, \"trie\"), \" of all the words in our vocabulary. An alphabet file that maps integer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"labels output by the network into characters.\")), mdx(\"p\", null, \"Although adding this many moving parts does make our code harder to modify and apply to different use cases (like other\\nlanguages), it brings great benefits: Our word error rate on LibriSpeech\\u2019s test-clean set went from 16% to 6.5%, which\\nnot only achieves our initial goal, but gets us close to human level performance (5.83% according to the Deep Speech 2\\npaper). On a MacBook Pro, using the GPU, the model can do inference at a real-time factor of around 0.3x, and around\\n1.4x on the CPU alone. (A real-time factor of 1x means you can transcribe 1 second of audio in 1 second.)\"), mdx(\"p\", null, \"It has been an incredible journey to get to this place: the initial release of our model! In the future we want to\\nrelease a model that\\u2019s fast enough to run on a mobile device or a Raspberry Pi.\"), mdx(\"p\", null, \"If this type of work sounds interesting or useful to you, come check out our repository on GitHub and our Discourse\\nchannel. We have a growing community of contributors and we\\u2019re excited to help you create and publish a model for your\\nlanguage.\"), mdx(\"h3\", {\n    \"id\": \"license\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#license\",\n    \"aria-label\": \"license permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"width\": \"16\",\n    \"height\": \"16\",\n    \"focusable\": \"false\",\n    \"viewBox\": \"0 0 16 16\"\n  }, \"\\n  \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"fill\": \"currentColor\",\n    \"d\": \"M4.441 7.38l.095.083.939.939-.708.707-.939-.939-2 2-.132.142a2.829 2.829 0 003.99 3.99l.142-.132 2-2-.939-.939.707-.708.94.94a1 1 0 01.083 1.32l-.083.094-2 2A3.828 3.828 0 01.972 9.621l.15-.158 2-2A1 1 0 014.34 7.31l.101.07zm7.413-3.234a.5.5 0 01.057.638l-.057.07-7 7a.5.5 0 01-.765-.638l.057-.07 7-7a.5.5 0 01.708 0zm3.023-3.025a3.829 3.829 0 01.15 5.257l-.15.158-2 2a1 1 0 01-1.32.083l-.094-.083-.94-.94.708-.707.939.94 2-2 .132-.142a2.829 2.829 0 00-3.99-3.99l-.142.131-2 2 .939.939-.707.708-.94-.94a1 1 0 01-.082-1.32l.083-.094 2-2a3.828 3.828 0 015.414 0z\"\n  }))), \"License\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://creativecommons.org/licenses/by-sa/3.0/\"\n  }, \"Creative Commons Attribution Share-Alike License v3.0\"), \" or any later\\nversion\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#the-architecture","title":"The Architecture"},{"url":"#the-data","title":"The Data"},{"url":"#the-hardware","title":"The Hardware"},{"url":"#putting-it-all-together","title":"Putting it All Together"},{"url":"#beam-scoring-with-a-language-model","title":"Beam Scoring with a Language Model"},{"url":"#license","title":"License"}]}}},"pageContext":{"frontmatter":{"title":"A Journey to <10% Word Error Rate","name":"Reuben Morais","picture":"https://secure.gravatar.com/avatar/a0806241b0bfd0b4339c8d987d98b6db?s=128&d=mm&r=g","date":"November 29, 2017"},"fileAbsolutePath":"/home/runner/work/coqui-ai.github.io/coqui-ai.github.io/src/pages/blog/stt/a-journey-to-10-word-error-rate.mdx"}},"staticQueryHashes":["1942088059","3709355695","932324783"]}